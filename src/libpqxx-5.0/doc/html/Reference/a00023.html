<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>libpqxx: pqxx::connection_base Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libpqxx
   &#160;<span id="projectnumber">5.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00023.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="a00216.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pqxx::connection_base Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="a00023.html" title="connection_base abstract base class; represents a connection to a database. ">connection_base</a> abstract base class; represents a connection to a database.  
 <a href="a00023.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="a00125_source.html">connection_base.hxx</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for pqxx::connection_base:</div>
<div class="dyncontent">
<div class="center"><img src="a00217.png" border="0" usemap="#pqxx_1_1connection__base_inherit__map" alt="Inheritance graph"/></div>
<map name="pqxx_1_1connection__base_inherit__map" id="pqxx_1_1connection__base_inherit__map">
<area shape="rect" id="node2" href="a00009.html" title="The ultimate template that defines a connection type. " alt="" coords="5,81,168,122"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a985f29750a981c8ba80bf91b22c2eee9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a985f29750a981c8ba80bf91b22c2eee9">error_verbosity</a> { <a class="el" href="a00023.html#a985f29750a981c8ba80bf91b22c2eee9af941ee6232e0e2704c00349b8b47feff">terse</a> =0, 
<a class="el" href="a00023.html#a985f29750a981c8ba80bf91b22c2eee9a3e74ba2b1506b7deb1fbea2834c574cf">normal</a> =1, 
<a class="el" href="a00023.html#a985f29750a981c8ba80bf91b22c2eee9aff78876e731a924c5e25b06033fced2d">verbose</a> =2
 }</td></tr>
<tr class="memdesc:a985f29750a981c8ba80bf91b22c2eee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error verbosity levels.  <a href="a00023.html#a985f29750a981c8ba80bf91b22c2eee9">More...</a><br/></td></tr>
<tr class="separator:a985f29750a981c8ba80bf91b22c2eee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a58f98af9c813bc85daa0ff2787605f99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a58f98af9c813bc85daa0ff2787605f99">disconnect</a> () PQXX_NOEXCEPT</td></tr>
<tr class="memdesc:a58f98af9c813bc85daa0ff2787605f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly close connection.  <a href="#a58f98af9c813bc85daa0ff2787605f99">More...</a><br/></td></tr>
<tr class="separator:a58f98af9c813bc85daa0ff2787605f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb51933d30f199f0a4efe4a35eff839"><td class="memItemLeft" align="right" valign="top">bool PQXX_PURE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a8fb51933d30f199f0a4efe4a35eff839">is_open</a> () const PQXX_NOEXCEPT</td></tr>
<tr class="memdesc:a8fb51933d30f199f0a4efe4a35eff839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is this connection open at the moment?  <a href="#a8fb51933d30f199f0a4efe4a35eff839">More...</a><br/></td></tr>
<tr class="separator:a8fb51933d30f199f0a4efe4a35eff839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202f719a96eeb2e9269008d475ebb3d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a202f719a96eeb2e9269008d475ebb3d0">process_notice</a> (const char[]) PQXX_NOEXCEPT</td></tr>
<tr class="memdesc:a202f719a96eeb2e9269008d475ebb3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke notice processor function. The message should end in newline.  <a href="#a202f719a96eeb2e9269008d475ebb3d0">More...</a><br/></td></tr>
<tr class="separator:a202f719a96eeb2e9269008d475ebb3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a38dd435013aa2dd77009bc6a5676f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a80a38dd435013aa2dd77009bc6a5676f">process_notice</a> (const std::string &amp;) PQXX_NOEXCEPT</td></tr>
<tr class="memdesc:a80a38dd435013aa2dd77009bc6a5676f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke notice processor function. Newline at end is recommended.  <a href="#a80a38dd435013aa2dd77009bc6a5676f">More...</a><br/></td></tr>
<tr class="separator:a80a38dd435013aa2dd77009bc6a5676f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a128da8bcea7991500b509e58b17ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a29a128da8bcea7991500b509e58b17ba">trace</a> (std::FILE *) PQXX_NOEXCEPT</td></tr>
<tr class="memdesc:a29a128da8bcea7991500b509e58b17ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable tracing to a given output stream, or NULL to disable.  <a href="#a29a128da8bcea7991500b509e58b17ba">More...</a><br/></td></tr>
<tr class="separator:a29a128da8bcea7991500b509e58b17ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04895c06c5ae1d8b0863a32a28beff51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a04895c06c5ae1d8b0863a32a28beff51">set_client_encoding</a> (const std::string &amp;Encoding)</td></tr>
<tr class="memdesc:a04895c06c5ae1d8b0863a32a28beff51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set client-side character encoding.  <a href="#a04895c06c5ae1d8b0863a32a28beff51">More...</a><br/></td></tr>
<tr class="separator:a04895c06c5ae1d8b0863a32a28beff51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120b9e03dcaa9b0c3ef7026afa64d954"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a120b9e03dcaa9b0c3ef7026afa64d954">set_variable</a> (const std::string &amp;Var, const std::string &amp;Value)</td></tr>
<tr class="memdesc:a120b9e03dcaa9b0c3ef7026afa64d954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set session variable.  <a href="#a120b9e03dcaa9b0c3ef7026afa64d954">More...</a><br/></td></tr>
<tr class="separator:a120b9e03dcaa9b0c3ef7026afa64d954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908a2ffdf56d8259492e9f3894e24f65"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a908a2ffdf56d8259492e9f3894e24f65">get_variable</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a908a2ffdf56d8259492e9f3894e24f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read session variable.  <a href="#a908a2ffdf56d8259492e9f3894e24f65">More...</a><br/></td></tr>
<tr class="separator:a908a2ffdf56d8259492e9f3894e24f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4963aaba6da521d480c21c7ec01835cf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a4963aaba6da521d480c21c7ec01835cf">adorn_name</a> (const std::string &amp;)</td></tr>
<tr class="memdesc:a4963aaba6da521d480c21c7ec01835cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suffix unique number to name to make it unique within session context.  <a href="#a4963aaba6da521d480c21c7ec01835cf">More...</a><br/></td></tr>
<tr class="separator:a4963aaba6da521d480c21c7ec01835cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8978ff727c03a1aaaa3a9d3fd3268abf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00196.html#ga8978ff727c03a1aaaa3a9d3fd3268abf">esc</a> (const char str[])</td></tr>
<tr class="memdesc:ga8978ff727c03a1aaaa3a9d3fd3268abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape string for use as SQL string literal on this connection.  <a href="a00196.html#ga8978ff727c03a1aaaa3a9d3fd3268abf">More...</a><br/></td></tr>
<tr class="separator:ga8978ff727c03a1aaaa3a9d3fd3268abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae711f65dd793a70629f97a2e0e54d8db"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00196.html#gae711f65dd793a70629f97a2e0e54d8db">esc</a> (const char str[], size_t maxlen)</td></tr>
<tr class="memdesc:gae711f65dd793a70629f97a2e0e54d8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape string for use as SQL string literal on this connection.  <a href="a00196.html#gae711f65dd793a70629f97a2e0e54d8db">More...</a><br/></td></tr>
<tr class="separator:gae711f65dd793a70629f97a2e0e54d8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca9ba750fd096cfd652a4323dab3a653"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00196.html#gaca9ba750fd096cfd652a4323dab3a653">esc</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gaca9ba750fd096cfd652a4323dab3a653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape string for use as SQL string literal on this connection.  <a href="a00196.html#gaca9ba750fd096cfd652a4323dab3a653">More...</a><br/></td></tr>
<tr class="separator:gaca9ba750fd096cfd652a4323dab3a653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a8c83d3dcea7114a00c188fe6a92779"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00196.html#ga6a8c83d3dcea7114a00c188fe6a92779">esc_raw</a> (const unsigned char str[], size_t len)</td></tr>
<tr class="memdesc:ga6a8c83d3dcea7114a00c188fe6a92779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape binary string for use as SQL string literal on this connection.  <a href="a00196.html#ga6a8c83d3dcea7114a00c188fe6a92779">More...</a><br/></td></tr>
<tr class="separator:ga6a8c83d3dcea7114a00c188fe6a92779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f7b54e5a166e325bf8949631e2f333b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00196.html#ga2f7b54e5a166e325bf8949631e2f333b">unesc_raw</a> (const std::string &amp;text)</td></tr>
<tr class="memdesc:ga2f7b54e5a166e325bf8949631e2f333b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unescape binary data, e.g. from a table field or notification payload.  <a href="a00196.html#ga2f7b54e5a166e325bf8949631e2f333b">More...</a><br/></td></tr>
<tr class="separator:ga2f7b54e5a166e325bf8949631e2f333b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3132eed320c58da86a2a5fc31f03f9d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00196.html#gae3132eed320c58da86a2a5fc31f03f9d">unesc_raw</a> (const char *text)</td></tr>
<tr class="memdesc:gae3132eed320c58da86a2a5fc31f03f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unescape binary data, e.g. from a table field or notification payload.  <a href="a00196.html#gae3132eed320c58da86a2a5fc31f03f9d">More...</a><br/></td></tr>
<tr class="separator:gae3132eed320c58da86a2a5fc31f03f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b59e512bedb3e8a69f3aa7e557daab7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00196.html#ga8b59e512bedb3e8a69f3aa7e557daab7">quote_raw</a> (const unsigned char str[], size_t len)</td></tr>
<tr class="memdesc:ga8b59e512bedb3e8a69f3aa7e557daab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape and quote a string of binary data.  <a href="a00196.html#ga8b59e512bedb3e8a69f3aa7e557daab7">More...</a><br/></td></tr>
<tr class="separator:ga8b59e512bedb3e8a69f3aa7e557daab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae68c4661843dcf695585f6e1b6011788"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00196.html#gae68c4661843dcf695585f6e1b6011788">quote_name</a> (const std::string &amp;identifier)</td></tr>
<tr class="memdesc:gae68c4661843dcf695585f6e1b6011788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape and quote an SQL identifier for use in a query.  <a href="a00196.html#gae68c4661843dcf695585f6e1b6011788">More...</a><br/></td></tr>
<tr class="separator:gae68c4661843dcf695585f6e1b6011788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81fe65fbb9561af7c5f0b33a9fe27e5a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga81fe65fbb9561af7c5f0b33a9fe27e5a"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00196.html#ga81fe65fbb9561af7c5f0b33a9fe27e5a">quote</a> (const T &amp;t)</td></tr>
<tr class="memdesc:ga81fe65fbb9561af7c5f0b33a9fe27e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represent object as SQL string, including quoting &amp; escaping.  <a href="a00196.html#ga81fe65fbb9561af7c5f0b33a9fe27e5a">More...</a><br/></td></tr>
<tr class="separator:ga81fe65fbb9561af7c5f0b33a9fe27e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e10c6bf1796584c0949383cb25541c2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00196.html#ga7e10c6bf1796584c0949383cb25541c2">quote</a> (const <a class="el" href="a00016.html">binarystring</a> &amp;)</td></tr>
<tr class="separator:ga7e10c6bf1796584c0949383cb25541c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9709e4738b1bfb1dba547381749908cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a9709e4738b1bfb1dba547381749908cb">cancel_query</a> ()</td></tr>
<tr class="memdesc:a9709e4738b1bfb1dba547381749908cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to cancel the ongoing query, if any.  <a href="#a9709e4738b1bfb1dba547381749908cb">More...</a><br/></td></tr>
<tr class="separator:a9709e4738b1bfb1dba547381749908cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8693430afb7aeefc136658c7ef10cb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#ae8693430afb7aeefc136658c7ef10cb3">set_verbosity</a> (<a class="el" href="a00023.html#a985f29750a981c8ba80bf91b22c2eee9">error_verbosity</a> verbosity) PQXX_NOEXCEPT</td></tr>
<tr class="memdesc:ae8693430afb7aeefc136658c7ef10cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set session verbosity.  <a href="#ae8693430afb7aeefc136658c7ef10cb3">More...</a><br/></td></tr>
<tr class="separator:ae8693430afb7aeefc136658c7ef10cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61bce87c6e35f136fbff6cf095f4ee3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a00023.html#a985f29750a981c8ba80bf91b22c2eee9">error_verbosity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a61bce87c6e35f136fbff6cf095f4ee3d">get_verbosity</a> () const PQXX_NOEXCEPT</td></tr>
<tr class="memdesc:a61bce87c6e35f136fbff6cf095f4ee3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve current error verbosity.  <a href="#a61bce87c6e35f136fbff6cf095f4ee3d">More...</a><br/></td></tr>
<tr class="separator:a61bce87c6e35f136fbff6cf095f4ee3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33280d29c4db47c1e71eb82df921691a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="a00036.html">errorhandler</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a33280d29c4db47c1e71eb82df921691a">get_errorhandlers</a> () const </td></tr>
<tr class="memdesc:a33280d29c4db47c1e71eb82df921691a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return pointers to the active errorhandlers.  <a href="#a33280d29c4db47c1e71eb82df921691a">More...</a><br/></td></tr>
<tr class="separator:a33280d29c4db47c1e71eb82df921691a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Activation</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Connections can be temporarily deactivated, or they can break because of overly impatient firewalls dropping TCP connections. Where possible, libpqxx will try to re-activate these when resume using them, or you can wake them up explicitly. You probably won't need this feature, but you should be aware of it. </p>
</div></td></tr>
<tr class="memitem:a1aa330287775aa1ff83f94714f772673"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a1aa330287775aa1ff83f94714f772673">activate</a> ()</td></tr>
<tr class="memdesc:a1aa330287775aa1ff83f94714f772673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly activate deferred or deactivated connection.  <a href="#a1aa330287775aa1ff83f94714f772673">More...</a><br/></td></tr>
<tr class="separator:a1aa330287775aa1ff83f94714f772673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b275082e18dbcb177a8871f92c7523"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a10b275082e18dbcb177a8871f92c7523">deactivate</a> ()</td></tr>
<tr class="memdesc:a10b275082e18dbcb177a8871f92c7523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicitly deactivate connection.  <a href="#a10b275082e18dbcb177a8871f92c7523">More...</a><br/></td></tr>
<tr class="separator:a10b275082e18dbcb177a8871f92c7523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf7ac72658efa92e702a06b1964747a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#aedf7ac72658efa92e702a06b1964747a">inhibit_reactivation</a> (bool inhibit)</td></tr>
<tr class="memdesc:aedf7ac72658efa92e702a06b1964747a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disallow (or permit) connection recovery.  <a href="#aedf7ac72658efa92e702a06b1964747a">More...</a><br/></td></tr>
<tr class="separator:aedf7ac72658efa92e702a06b1964747a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335ca1d83e65a9e57b907c431c3afbe1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a335ca1d83e65a9e57b907c431c3afbe1">simulate_failure</a> ()</td></tr>
<tr class="memdesc:a335ca1d83e65a9e57b907c431c3afbe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make the connection fail.  <a href="#a335ca1d83e65a9e57b907c431c3afbe1">More...</a><br/></td></tr>
<tr class="separator:a335ca1d83e65a9e57b907c431c3afbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Connection properties</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are probably not of great interest, since most are derived from information supplied by the client program itself, but they are included for completeness. </p>
</div></td></tr>
<tr class="memitem:a043e536c1923594c246f2ca8db31dffa"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a043e536c1923594c246f2ca8db31dffa">dbname</a> ()</td></tr>
<tr class="memdesc:a043e536c1923594c246f2ca8db31dffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of database we're connected to, if any.  <a href="#a043e536c1923594c246f2ca8db31dffa">More...</a><br/></td></tr>
<tr class="separator:a043e536c1923594c246f2ca8db31dffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02522000400fc2782e892ac0387d85b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#ae02522000400fc2782e892ac0387d85b">username</a> ()</td></tr>
<tr class="memdesc:ae02522000400fc2782e892ac0387d85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Database user ID we're connected under, if any.  <a href="#ae02522000400fc2782e892ac0387d85b">More...</a><br/></td></tr>
<tr class="separator:ae02522000400fc2782e892ac0387d85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38dde9befa350a07a5ac093d13ee64e2"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a38dde9befa350a07a5ac093d13ee64e2">hostname</a> ()</td></tr>
<tr class="memdesc:a38dde9befa350a07a5ac093d13ee64e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Address of server, or NULL if none specified (i.e. default or local)  <a href="#a38dde9befa350a07a5ac093d13ee64e2">More...</a><br/></td></tr>
<tr class="separator:a38dde9befa350a07a5ac093d13ee64e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826750f0f13ede4ac4e6ca8a84711b53"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a826750f0f13ede4ac4e6ca8a84711b53">port</a> ()</td></tr>
<tr class="memdesc:a826750f0f13ede4ac4e6ca8a84711b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Server port number we're connected to.  <a href="#a826750f0f13ede4ac4e6ca8a84711b53">More...</a><br/></td></tr>
<tr class="separator:a826750f0f13ede4ac4e6ca8a84711b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69bad7d3305011fa238663ce2e62740"><td class="memItemLeft" align="right" valign="top">int PQXX_PURE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#ae69bad7d3305011fa238663ce2e62740">backendpid</a> () const PQXX_NOEXCEPT</td></tr>
<tr class="memdesc:ae69bad7d3305011fa238663ce2e62740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process ID for backend process.  <a href="#ae69bad7d3305011fa238663ce2e62740">More...</a><br/></td></tr>
<tr class="separator:ae69bad7d3305011fa238663ce2e62740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83b8717abba48d933df17df06643ee4"><td class="memItemLeft" align="right" valign="top">int PQXX_PURE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#ae83b8717abba48d933df17df06643ee4">sock</a> () const PQXX_NOEXCEPT</td></tr>
<tr class="memdesc:ae83b8717abba48d933df17df06643ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Socket currently used for connection, or -1 for none. Use with care!  <a href="#ae83b8717abba48d933df17df06643ee4">More...</a><br/></td></tr>
<tr class="separator:ae83b8717abba48d933df17df06643ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Notifications and Receivers</div></td></tr>
<tr class="memitem:aa839a066c0289a12f664e29c9dbafd38"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#aa839a066c0289a12f664e29c9dbafd38">get_notifs</a> ()</td></tr>
<tr class="memdesc:aa839a066c0289a12f664e29c9dbafd38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check for pending notifications and take appropriate action.  <a href="#aa839a066c0289a12f664e29c9dbafd38">More...</a><br/></td></tr>
<tr class="separator:aa839a066c0289a12f664e29c9dbafd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c24029bda3198d826d24757e49c746"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#ab5c24029bda3198d826d24757e49c746">await_notification</a> ()</td></tr>
<tr class="memdesc:ab5c24029bda3198d826d24757e49c746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a notification to come in.  <a href="#ab5c24029bda3198d826d24757e49c746">More...</a><br/></td></tr>
<tr class="separator:ab5c24029bda3198d826d24757e49c746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e66faad88a94857c0749b9bbc5d352"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#aa9e66faad88a94857c0749b9bbc5d352">await_notification</a> (long seconds, long microseconds)</td></tr>
<tr class="memdesc:aa9e66faad88a94857c0749b9bbc5d352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for a notification to come in, or for given timeout to pass.  <a href="#aa9e66faad88a94857c0749b9bbc5d352">More...</a><br/></td></tr>
<tr class="separator:aa9e66faad88a94857c0749b9bbc5d352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Prepared statements</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>PostgreSQL supports prepared SQL statements, i.e. statements that can be registered under a client-provided name, optimized once by the backend, and executed any number of times under the given name.</p>
<p>Prepared statement definitions are not sensitive to transaction boundaries; a statement defined inside a transaction will remain defined outside that transaction, even if the transaction itself is subsequently aborted. Once a statement has been prepared, only closing the connection or explicitly "unpreparing" it can make it go away.</p>
<p>Use the transaction classes' <code>prepared()</code>.exec() function to execute a prepared statement. Use <code>prepared()</code>.exists() to find out whether a statement has been prepared under a given name.</p>
<p>A special case is the nameless prepared statement. You may prepare a statement without a name. The unnamed statement can be redefined at any time, without un-preparing it first.</p>
<dl class="section warning"><dt>Warning</dt><dd>Prepared statements are not necessarily defined on the backend right away; libpqxx generally does that lazily. This means that you can prepare statements before the connection is fully established, and that it's relatively cheap to pre-prepare lots of statements that you may or may not use during the session. On the other hand, it also means that errors in a prepared statement may not show up until you first try to invoke it. Such an error may then break the transaction it occurs in.</dd>
<dd>
Never try to prepare, execute, or unprepare a prepared statement manually using direct SQL queries. Always use the functions provided by libpqxx. </dd></dl>
</div></td></tr>
<tr class="memitem:ab71d463277c017f695eed71cdd87afb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#ab71d463277c017f695eed71cdd87afb2">prepare</a> (const std::string &amp;name, const std::string &amp;definition)</td></tr>
<tr class="memdesc:ab71d463277c017f695eed71cdd87afb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a prepared statement.  <a href="#ab71d463277c017f695eed71cdd87afb2">More...</a><br/></td></tr>
<tr class="separator:ab71d463277c017f695eed71cdd87afb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3fc0b15713b0bba8a6a286e4e67c10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a2d3fc0b15713b0bba8a6a286e4e67c10">prepare</a> (const std::string &amp;definition)</td></tr>
<tr class="memdesc:a2d3fc0b15713b0bba8a6a286e4e67c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a nameless prepared statement.  <a href="#a2d3fc0b15713b0bba8a6a286e4e67c10">More...</a><br/></td></tr>
<tr class="separator:a2d3fc0b15713b0bba8a6a286e4e67c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ec51634479614b45106532e87e5dc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a30ec51634479614b45106532e87e5dc7">unprepare</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a30ec51634479614b45106532e87e5dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop prepared statement.  <a href="#a30ec51634479614b45106532e87e5dc7">More...</a><br/></td></tr>
<tr class="separator:a30ec51634479614b45106532e87e5dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32efdc645566975851bfc7d6b82d214c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a32efdc645566975851bfc7d6b82d214c">prepare_now</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a32efdc645566975851bfc7d6b82d214c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request that prepared statement be registered with the server.  <a href="#a32efdc645566975851bfc7d6b82d214c">More...</a><br/></td></tr>
<tr class="separator:a32efdc645566975851bfc7d6b82d214c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Transactor framework</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>See the transactor class template for more about transactors. To use the transactor framework, encapsulate your transaction code in a class derived from an instantiation of the <a class="el" href="a00104.html">pqxx::transactor</a> template. Then, to execute it, create an object of your transactor class and pass it to one of the <a class="el" href="a00023.html#abf3b71372850f86e4f5e67eb4b7d56bd" title="Perform the transaction defined by a transactor-based object. ">perform()</a> functions here.</p>
<p>The <a class="el" href="a00023.html#abf3b71372850f86e4f5e67eb4b7d56bd" title="Perform the transaction defined by a transactor-based object. ">perform()</a> functions may create and execute several copies of the transactor before succeeding or ultimately giving up. If there is any doubt over whether execution succeeded (this can happen if the connection to the server is lost just before the backend can confirm success), it is no longer retried and an <a class="el" href="a00045.html" title="&quot;Help, I don&#39;t know whether transaction was committed successfully!&quot; ">in_doubt_error</a> is thrown.</p>
<p>Take care: no member functions will ever be invoked on the transactor object you pass into <a class="el" href="a00023.html#abf3b71372850f86e4f5e67eb4b7d56bd" title="Perform the transaction defined by a transactor-based object. ">perform()</a>. The object you pass in only serves as a "prototype" for the job to be done. The <a class="el" href="a00023.html#abf3b71372850f86e4f5e67eb4b7d56bd" title="Perform the transaction defined by a transactor-based object. ">perform()</a> function will copy-construct transactors from the original you passed in, executing the copies only. The original object remains "clean" in its original state. </p>
</div></td></tr>
<tr class="memitem:abf3b71372850f86e4f5e67eb4b7d56bd"><td class="memTemplParams" colspan="2">template&lt;typename TRANSACTOR &gt; </td></tr>
<tr class="memitem:abf3b71372850f86e4f5e67eb4b7d56bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00023.html#abf3b71372850f86e4f5e67eb4b7d56bd">perform</a> (const TRANSACTOR &amp;T, int Attempts)</td></tr>
<tr class="memdesc:abf3b71372850f86e4f5e67eb4b7d56bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the transaction defined by a transactor-based object.  <a href="#abf3b71372850f86e4f5e67eb4b7d56bd">More...</a><br/></td></tr>
<tr class="separator:abf3b71372850f86e4f5e67eb4b7d56bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eac9840b79e7f1893d88b63f6d97b1d"><td class="memTemplParams" colspan="2">template&lt;typename TRANSACTOR &gt; </td></tr>
<tr class="memitem:a5eac9840b79e7f1893d88b63f6d97b1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00023.html#a5eac9840b79e7f1893d88b63f6d97b1d">perform</a> (const TRANSACTOR &amp;T)</td></tr>
<tr class="memdesc:a5eac9840b79e7f1893d88b63f6d97b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform the transaction defined by a transactor-based object.  <a href="#a5eac9840b79e7f1893d88b63f6d97b1d">More...</a><br/></td></tr>
<tr class="separator:a5eac9840b79e7f1893d88b63f6d97b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a33700cc6d830d28c3dbd48eb9b7276ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a33700cc6d830d28c3dbd48eb9b7276ab">connection_base</a> (<a class="el" href="a00024.html">connectionpolicy</a> &amp;)</td></tr>
<tr class="separator:a33700cc6d830d28c3dbd48eb9b7276ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1c129c2c5797a82f251ee9dabec77e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a1d1c129c2c5797a82f251ee9dabec77e">init</a> ()</td></tr>
<tr class="separator:a1d1c129c2c5797a82f251ee9dabec77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f863e7f06b82a2f0e71af8627d58db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#af1f863e7f06b82a2f0e71af8627d58db">close</a> () PQXX_NOEXCEPT</td></tr>
<tr class="separator:af1f863e7f06b82a2f0e71af8627d58db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af860fe4c418cfa4f573f34d73327d111"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#af860fe4c418cfa4f573f34d73327d111">wait_read</a> () const </td></tr>
<tr class="separator:af860fe4c418cfa4f573f34d73327d111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c7dd5e54493e18d5900dd70012d062"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#ab8c7dd5e54493e18d5900dd70012d062">wait_read</a> (long seconds, long microseconds) const </td></tr>
<tr class="separator:ab8c7dd5e54493e18d5900dd70012d062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb8d53e6f105db280cd5d977c005bea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#acfb8d53e6f105db280cd5d977c005bea">wait_write</a> () const </td></tr>
<tr class="separator:acfb8d53e6f105db280cd5d977c005bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac2eff365ba0aa25ebbf5f903ac3c7a54"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#ac2eff365ba0aa25ebbf5f903ac3c7a54">internal::gate::connection_prepare_invocation</a></td></tr>
<tr class="separator:ac2eff365ba0aa25ebbf5f903ac3c7a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa423170b8ec82df685a1e739f53f2b14"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#aa423170b8ec82df685a1e739f53f2b14">internal::gate::connection_errorhandler</a></td></tr>
<tr class="separator:aa423170b8ec82df685a1e739f53f2b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c60c76e32687adce1e8c0dba0919773"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a3c60c76e32687adce1e8c0dba0919773">internal::gate::connection_transaction</a></td></tr>
<tr class="separator:a3c60c76e32687adce1e8c0dba0919773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15ff67d81467d271dc713b2584f1328"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#ab15ff67d81467d271dc713b2584f1328">internal::gate::connection_largeobject</a></td></tr>
<tr class="separator:ab15ff67d81467d271dc713b2584f1328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdbf8e505eb3c23680d83df6c575889"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#abbdbf8e505eb3c23680d83df6c575889">internal::gate::connection_notification_receiver</a></td></tr>
<tr class="separator:abbdbf8e505eb3c23680d83df6c575889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9c5dc16f04600aa5415e06f6ff8fa6"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a3b9c5dc16f04600aa5415e06f6ff8fa6">internal::gate::connection_pipeline</a></td></tr>
<tr class="separator:a3b9c5dc16f04600aa5415e06f6ff8fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3dfec559fe2305e57aba653abe4c8ad"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#af3dfec559fe2305e57aba653abe4c8ad">internal::gate::connection_dbtransaction</a></td></tr>
<tr class="separator:af3dfec559fe2305e57aba653abe4c8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c1a28176815ab9103c7febec450755"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a84c1a28176815ab9103c7febec450755">internal::gate::connection_sql_cursor</a></td></tr>
<tr class="separator:a84c1a28176815ab9103c7febec450755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2247d8690958f634898bbf014a7d418c"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a2247d8690958f634898bbf014a7d418c">internal::gate::connection_reactivation_avoidance_exemption</a></td></tr>
<tr class="separator:a2247d8690958f634898bbf014a7d418c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e64dc314f291c6f81a948c59d94aa8a"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a0e64dc314f291c6f81a948c59d94aa8a">internal::gate::connection_parameterized_invocation</a></td></tr>
<tr class="separator:a0e64dc314f291c6f81a948c59d94aa8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Capabilities</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp82ec2cd6fda87713f588da75c3b1d0ed"></a>Some functionality may only be available in certain versions of the backend, or only when speaking certain versions of the communications protocol that connects us to the backend. </p>
</td></tr>
<tr class="memitem:a306a884246abc1051bab4fb06393ee71"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a306a884246abc1051bab4fb06393ee71">capability</a> { <br/>
&#160;&#160;<a class="el" href="a00023.html#a306a884246abc1051bab4fb06393ee71af5a4754aea608aaf5fca6caa51c44ce0">cap_prepared_statements</a>, 
<a class="el" href="a00023.html#a306a884246abc1051bab4fb06393ee71aba8a02f6bb5d2304bfbf2110c6cd791a">cap_create_table_with_oids</a>, 
<a class="el" href="a00023.html#a306a884246abc1051bab4fb06393ee71a973dc9e4f56818f82b86fb13a5bbc405">cap_nested_transactions</a>, 
<a class="el" href="a00023.html#a306a884246abc1051bab4fb06393ee71a8034abdbcd193f25d9d93cf79156e1fc">cap_cursor_scroll</a>, 
<br/>
&#160;&#160;<a class="el" href="a00023.html#a306a884246abc1051bab4fb06393ee71ad97556afc36aff4a62c61b67437c20c4">cap_cursor_with_hold</a>, 
<a class="el" href="a00023.html#a306a884246abc1051bab4fb06393ee71a8ab47c10b60d6bd6664f6e88f300edcb">cap_cursor_update</a>, 
<a class="el" href="a00023.html#a306a884246abc1051bab4fb06393ee71a86380c8c083847ba3d16764784f5914f">cap_cursor_fetch_0</a>, 
<a class="el" href="a00023.html#a306a884246abc1051bab4fb06393ee71a1f2b785abe834490c33dc4cf19c932d2">cap_table_column</a>, 
<br/>
&#160;&#160;<a class="el" href="a00023.html#a306a884246abc1051bab4fb06393ee71a01e68a67b6a3c92ce9b0c92fa73e90b2">cap_read_only_transactions</a>, 
<a class="el" href="a00023.html#a306a884246abc1051bab4fb06393ee71abefe533e379346c7b9644406c613eb02">cap_statement_varargs</a>, 
<a class="el" href="a00023.html#a306a884246abc1051bab4fb06393ee71a6b019128f2fdcfa9d316042342846e2f">cap_prepare_unnamed_statement</a>, 
<a class="el" href="a00023.html#a306a884246abc1051bab4fb06393ee71a366c98bc3385ecfb39496bf7240e5973">cap_parameterized_statements</a>, 
<br/>
&#160;&#160;<a class="el" href="a00023.html#a306a884246abc1051bab4fb06393ee71aabb5fb3d6d43442107e04e0982300d6e">cap_notify_payload</a>, 
<a class="el" href="a00023.html#a306a884246abc1051bab4fb06393ee71a4a873c5d7e7fb0a9022cdd110181a7de">cap_end</a>
<br/>
 }</td></tr>
<tr class="memdesc:a306a884246abc1051bab4fb06393ee71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Session capabilities.  <a href="a00023.html#a306a884246abc1051bab4fb06393ee71">More...</a><br/></td></tr>
<tr class="separator:a306a884246abc1051bab4fb06393ee71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff3f9172fa6b1c6b96359502536ad1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a8ff3f9172fa6b1c6b96359502536ad1d">supports</a> (<a class="el" href="a00023.html#a306a884246abc1051bab4fb06393ee71">capability</a> c) const PQXX_NOEXCEPT</td></tr>
<tr class="memdesc:a8ff3f9172fa6b1c6b96359502536ad1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this connection seem to support the given capability?  <a href="#a8ff3f9172fa6b1c6b96359502536ad1d">More...</a><br/></td></tr>
<tr class="separator:a8ff3f9172fa6b1c6b96359502536ad1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d8108b0d5c95e7e3b8bb79c71ee363"><td class="memItemLeft" align="right" valign="top">int PQXX_PURE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a08d8108b0d5c95e7e3b8bb79c71ee363">protocol_version</a> () const PQXX_NOEXCEPT</td></tr>
<tr class="memdesc:a08d8108b0d5c95e7e3b8bb79c71ee363"><td class="mdescLeft">&#160;</td><td class="mdescRight">What version of the PostgreSQL protocol is this connection using?  <a href="#a08d8108b0d5c95e7e3b8bb79c71ee363">More...</a><br/></td></tr>
<tr class="separator:a08d8108b0d5c95e7e3b8bb79c71ee363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575d985e6f1462ae506e7e7047929680"><td class="memItemLeft" align="right" valign="top">int PQXX_PURE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00023.html#a575d985e6f1462ae506e7e7047929680">server_version</a> () const PQXX_NOEXCEPT</td></tr>
<tr class="memdesc:a575d985e6f1462ae506e7e7047929680"><td class="mdescLeft">&#160;</td><td class="mdescRight">What version of the PostgreSQL server are we connected to?  <a href="#a575d985e6f1462ae506e7e7047929680">More...</a><br/></td></tr>
<tr class="separator:a575d985e6f1462ae506e7e7047929680"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="a00023.html" title="connection_base abstract base class; represents a connection to a database. ">connection_base</a> abstract base class; represents a connection to a database. </p>
<p>This is the first class to look at when you wish to work with a database through libpqxx. Depending on the implementing concrete child class, a connection can be automatically opened when it is constructed, or when it is first used, or somewhere inbetween. The connection is automatically closed upon destruction (if it hasn't been closed already).</p>
<p>To query or manipulate the database once connected, use one of the transaction classes (see <a class="el" href="a00169_source.html">pqxx/transaction_base.hxx</a>) or preferably the transactor framework (see <a class="el" href="a00170_source.html">pqxx/transactor.hxx</a>).</p>
<p>If a network connection to the database server fails, the connection will be restored automatically (although any transaction going on at the time will have to be aborted). This also means that any information set in previous transactions that is not stored in the database, such as temp tables or connection-local variables defined with PostgreSQL's SET command, will be lost. Whenever you create such state, either keept it local to one transaction, where possible, or inhibit automatic reactivation of the connection using the <a class="el" href="a00023.html#aedf7ac72658efa92e702a06b1964747a" title="Disallow (or permit) connection recovery. ">inhibit_reactivation()</a> method.</p>
<p>When a connection breaks, you will typically get a <a class="el" href="a00017.html" title="Exception class for lost or failed backend connection. ">broken_connection</a> exception. This can happen at almost any point, and the details may depend on which connection class (all derived from this one) you use.</p>
<p>As a general rule, always avoid raw queries if libpqxx offers a dedicated function for the same purpose. There may be hidden logic to hide certain complications from you, such as reinstating session variables when a broken or disabled connection is reactivated.</p>
<dl class="section warning"><dt>Warning</dt><dd>On Unix-like systems, including GNU and BSD systems, your program may receive the SIGPIPE signal when the connection to the backend breaks. By default this signal will abort your program. Use "signal(SIGPIPE, SIG_IGN)" if you want your program to continue running after a connection fails. </dd></dl>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a306a884246abc1051bab4fb06393ee71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00023.html#a306a884246abc1051bab4fb06393ee71">pqxx::connection_base::capability</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Session capabilities. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a306a884246abc1051bab4fb06393ee71af5a4754aea608aaf5fca6caa51c44ce0"></a>cap_prepared_statements</em>&#160;</td><td class="fielddoc">
<p>Does the backend support prepared statements? </p>
<dl class="deprecated"><dt><b><a class="el" href="a00203.html#_deprecated000001">Deprecated:</a></b></dt><dd>Always supported in libpqxx 5.0 or better. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a306a884246abc1051bab4fb06393ee71aba8a02f6bb5d2304bfbf2110c6cd791a"></a>cap_create_table_with_oids</em>&#160;</td><td class="fielddoc">
<p>Can we specify WITH OIDS with CREATE TABLE? </p>
<dl class="deprecated"><dt><b><a class="el" href="a00203.html#_deprecated000002">Deprecated:</a></b></dt><dd>Always supported in libpqxx 5.0 or better. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a306a884246abc1051bab4fb06393ee71a973dc9e4f56818f82b86fb13a5bbc405"></a>cap_nested_transactions</em>&#160;</td><td class="fielddoc">
<p>Can transactions be nested in other transactions? </p>
<dl class="deprecated"><dt><b><a class="el" href="a00203.html#_deprecated000003">Deprecated:</a></b></dt><dd>Always supported in libpqxx 5.0 or better. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a306a884246abc1051bab4fb06393ee71a8034abdbcd193f25d9d93cf79156e1fc"></a>cap_cursor_scroll</em>&#160;</td><td class="fielddoc">
<p>Can cursors be declared SCROLL? </p>
<dl class="deprecated"><dt><b><a class="el" href="a00203.html#_deprecated000004">Deprecated:</a></b></dt><dd>Always supported in libpqxx 5.0 or better. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a306a884246abc1051bab4fb06393ee71ad97556afc36aff4a62c61b67437c20c4"></a>cap_cursor_with_hold</em>&#160;</td><td class="fielddoc">
<p>Can cursors be declared WITH HOLD? </p>
<dl class="deprecated"><dt><b><a class="el" href="a00203.html#_deprecated000005">Deprecated:</a></b></dt><dd>Always supported in libpqxx 5.0 or better. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a306a884246abc1051bab4fb06393ee71a8ab47c10b60d6bd6664f6e88f300edcb"></a>cap_cursor_update</em>&#160;</td><td class="fielddoc">
<p>Can cursors be updateable? </p>
<dl class="deprecated"><dt><b><a class="el" href="a00203.html#_deprecated000006">Deprecated:</a></b></dt><dd>Always supported in libpqxx 5.0 or better. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a306a884246abc1051bab4fb06393ee71a86380c8c083847ba3d16764784f5914f"></a>cap_cursor_fetch_0</em>&#160;</td><td class="fielddoc">
<p>Can cursors fetch zero elements? (Used to trigger a "fetch all") </p>
<dl class="deprecated"><dt><b><a class="el" href="a00203.html#_deprecated000007">Deprecated:</a></b></dt><dd>Always supported in libpqxx 5.0 or better. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a306a884246abc1051bab4fb06393ee71a1f2b785abe834490c33dc4cf19c932d2"></a>cap_table_column</em>&#160;</td><td class="fielddoc">
<p>Can we ask what table column a result column came from? </p>
<dl class="deprecated"><dt><b><a class="el" href="a00203.html#_deprecated000008">Deprecated:</a></b></dt><dd>Always supported in libpqxx 5.0 or better. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a306a884246abc1051bab4fb06393ee71a01e68a67b6a3c92ce9b0c92fa73e90b2"></a>cap_read_only_transactions</em>&#160;</td><td class="fielddoc">
<p>Can transactions be READ ONLY? </p>
<dl class="deprecated"><dt><b><a class="el" href="a00203.html#_deprecated000009">Deprecated:</a></b></dt><dd>Always supported in libpqxx 5.0 or better. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a306a884246abc1051bab4fb06393ee71abefe533e379346c7b9644406c613eb02"></a>cap_statement_varargs</em>&#160;</td><td class="fielddoc">
<p>Do prepared statements support varargs? </p>
<dl class="deprecated"><dt><b><a class="el" href="a00203.html#_deprecated000010">Deprecated:</a></b></dt><dd>Always supported in libpqxx 5.0 or better. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a306a884246abc1051bab4fb06393ee71a6b019128f2fdcfa9d316042342846e2f"></a>cap_prepare_unnamed_statement</em>&#160;</td><td class="fielddoc">
<p>Is the unnamed prepared statement supported? </p>
<dl class="deprecated"><dt><b><a class="el" href="a00203.html#_deprecated000011">Deprecated:</a></b></dt><dd>Always supported in libpqxx 5.0 or better. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a306a884246abc1051bab4fb06393ee71a366c98bc3385ecfb39496bf7240e5973"></a>cap_parameterized_statements</em>&#160;</td><td class="fielddoc">
<p>Can this connection execute parameterized statements? </p>
<dl class="deprecated"><dt><b><a class="el" href="a00203.html#_deprecated000012">Deprecated:</a></b></dt><dd>Always supported in libpqxx 5.0 or better. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a306a884246abc1051bab4fb06393ee71aabb5fb3d6d43442107e04e0982300d6e"></a>cap_notify_payload</em>&#160;</td><td class="fielddoc">
<p>Can notifications carry payloads? </p>
<dl class="deprecated"><dt><b><a class="el" href="a00203.html#_deprecated000013">Deprecated:</a></b></dt><dd>Always supported in libpqxx 5.0 or better. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a306a884246abc1051bab4fb06393ee71a4a873c5d7e7fb0a9022cdd110181a7de"></a>cap_end</em>&#160;</td><td class="fielddoc">
<p>Not a capability value; end-of-enumeration marker. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a985f29750a981c8ba80bf91b22c2eee9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="a00023.html#a985f29750a981c8ba80bf91b22c2eee9">pqxx::connection_base::error_verbosity</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error verbosity levels. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a985f29750a981c8ba80bf91b22c2eee9af941ee6232e0e2704c00349b8b47feff"></a>terse</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a985f29750a981c8ba80bf91b22c2eee9a3e74ba2b1506b7deb1fbea2834c574cf"></a>normal</em>&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a985f29750a981c8ba80bf91b22c2eee9aff78876e731a924c5e25b06033fced2d"></a>verbose</em>&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a33700cc6d830d28c3dbd48eb9b7276ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pqxx::connection_base::connection_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00024.html">connectionpolicy</a> &amp;&#160;</td>
          <td class="paramname"><em>pol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1aa330287775aa1ff83f94714f772673"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::activate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly activate deferred or deactivated connection. </p>
<p>Use of this method is entirely optional. Whenever a connection is used while in a deferred or deactivated state, it will transparently try to bring itself into an activated state. This function is best viewed as an explicit hint to the connection that "if you're not in an active state, now
would be a good time to get into one." Whether a connection is currently in an active state or not makes no real difference to its functionality. There is also no particular need to match calls to <a class="el" href="a00023.html#a1aa330287775aa1ff83f94714f772673" title="Explicitly activate deferred or deactivated connection. ">activate()</a> with calls to <a class="el" href="a00023.html#a10b275082e18dbcb177a8871f92c7523" title="Explicitly deactivate connection. ">deactivate()</a>. A good time to call <a class="el" href="a00023.html#a1aa330287775aa1ff83f94714f772673" title="Explicitly activate deferred or deactivated connection. ">activate()</a> might be just before you first open a transaction on a lazy connection. </p>

<p>Referenced by <a class="el" href="a00083.html#a78ee80852828a1221357352ce77b9597">pqxx::internal::sql_cursor::sql_cursor()</a>.</p>

</div>
</div>
<a class="anchor" id="a4963aaba6da521d480c21c7ec01835cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string pqxx::connection_base::adorn_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suffix unique number to name to make it unique within session context. </p>
<p>Used internally to generate identifiers for SQL objects (such as cursors and nested transactions) based on a given human-readable base name. </p>

<p>References <a class="el" href="a00186.html#a4000e0b1288512dd1193b4dd442e6889">pqxx::to_string()</a>.</p>

</div>
</div>
<a class="anchor" id="ab5c24029bda3198d826d24757e49c746"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pqxx::connection_base::await_notification </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a notification to come in. </p>
<p>The wait may also be terminated by other events, such as the connection to the backend failing. Any pending or received notifications are processed as part of the call.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of notifications processed </dd></dl>

<p>References <a class="el" href="a00187.html#aab24f7cf8fda5527887819f620eea4be">pqxx::internal::wait_read()</a>.</p>

</div>
</div>
<a class="anchor" id="aa9e66faad88a94857c0749b9bbc5d352"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pqxx::connection_base::await_notification </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>seconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>microseconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for a notification to come in, or for given timeout to pass. </p>
<p>The wait may also be terminated by other events, such as the connection to the backend failing. Any pending or received notifications are processed as part of the call.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of notifications processed </dd></dl>

<p>References <a class="el" href="a00187.html#aab24f7cf8fda5527887819f620eea4be">pqxx::internal::wait_read()</a>.</p>

</div>
</div>
<a class="anchor" id="ae69bad7d3305011fa238663ce2e62740"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pqxx::connection_base::backendpid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process ID for backend process. </p>
<p>Use with care: connections may be lost and automatically re-established without your knowledge, in which case this process ID may no longer be correct. You may, however, assume that this number remains constant and reliable within the span of a successful backend transaction. If the transaction fails, which may be due to a lost connection, then this number will have become invalid at some point within the transaction.</p>
<dl class="section return"><dt>Returns</dt><dd>Process identifier, or 0 if not currently connected. </dd></dl>

</div>
</div>
<a class="anchor" id="a9709e4738b1bfb1dba547381749908cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::cancel_query </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempt to cancel the ongoing query, if any. </p>

</div>
</div>
<a class="anchor" id="af1f863e7f06b82a2f0e71af8627d58db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="a00009.html#af400015c10c351bcdf384067f71becf0">pqxx::basic_connection&lt; CONNECTPOLICY &gt;::~basic_connection()</a>.</p>

</div>
</div>
<a class="anchor" id="a043e536c1923594c246f2ca8db31dffa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * pqxx::connection_base::dbname </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of database we're connected to, if any. </p>
<dl class="section warning"><dt>Warning</dt><dd>This activates the connection, which may fail with a <a class="el" href="a00017.html" title="Exception class for lost or failed backend connection. ">broken_connection</a> exception. </dd></dl>

</div>
</div>
<a class="anchor" id="a10b275082e18dbcb177a8871f92c7523"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::deactivate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly deactivate connection. </p>
<p>Like its counterpart <a class="el" href="a00023.html#a1aa330287775aa1ff83f94714f772673" title="Explicitly activate deferred or deactivated connection. ">activate()</a>, this method is entirely optional. Calling this function really only makes sense if you won't be using this connection for a while and want to reduce the number of open connections on the database server. There is no particular need to match or pair calls to <a class="el" href="a00023.html#a10b275082e18dbcb177a8871f92c7523" title="Explicitly deactivate connection. ">deactivate()</a> with calls to <a class="el" href="a00023.html#a1aa330287775aa1ff83f94714f772673" title="Explicitly activate deferred or deactivated connection. ">activate()</a>, but calling <a class="el" href="a00023.html#a10b275082e18dbcb177a8871f92c7523" title="Explicitly deactivate connection. ">deactivate()</a> during a transaction is an error. </p>

</div>
</div>
<a class="anchor" id="a58f98af9c813bc85daa0ff2787605f99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::disconnect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explicitly close connection. </p>

</div>
</div>
<a class="anchor" id="a33280d29c4db47c1e71eb82df921691a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="a00036.html">errorhandler</a> * &gt; pqxx::connection_base::get_errorhandlers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return pointers to the active errorhandlers. </p>
<p>The entries are ordered from oldest to newest handler.</p>
<p>You may use this to find errorhandlers that your application wants to delete when destroying the connection. Be aware, however, that libpqxx may also add errorhandlers of its own, and those will be included in the list. If this is a problem for you, derive your errorhandlers from a custom base class derived from <a class="el" href="a00036.html" title="Base class for error-handler callbacks. ">pqxx::errorhandler</a>. Then use dynamic_cast to find which of the error handlers are yours.</p>
<p>The pointers point to the real errorhandlers. The container it returns however is a copy of the one internal to the connection, not a reference. </p>

</div>
</div>
<a class="anchor" id="aa839a066c0289a12f664e29c9dbafd38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pqxx::connection_base::get_notifs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check for pending notifications and take appropriate action. </p>
<p>All notifications found pending at call time are processed by finding any matching receivers and invoking those. If no receivers matched the notification string, none are invoked but the notification is considered processed.</p>
<p>Exceptions thrown by client-registered receivers are reported using the connection's errorhandlers, but the exceptions themselves are not passed on outside this function.</p>
<dl class="section return"><dt>Returns</dt><dd>Number of notifications processed </dd></dl>

</div>
</div>
<a class="anchor" id="a908a2ffdf56d8259492e9f3894e24f65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string pqxx::connection_base::get_variable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>Var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read session variable. </p>
<p>Will try to read the value locally, from the list of variables set with the set_variable function. If that fails, the database is queried. </p>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix the set_variable interface with manual setting of variables by executing the corresponding SQL commands, and do not get or set variables while a tablestream or pipeline is active on the same connection. </dd></dl>

</div>
</div>
<a class="anchor" id="a61bce87c6e35f136fbff6cf095f4ee3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00023.html#a985f29750a981c8ba80bf91b22c2eee9">error_verbosity</a> pqxx::connection_base::get_verbosity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve current error verbosity. </p>

</div>
</div>
<a class="anchor" id="a38dde9befa350a07a5ac093d13ee64e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * pqxx::connection_base::hostname </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Address of server, or NULL if none specified (i.e. default or local) </p>
<dl class="section warning"><dt>Warning</dt><dd>This activates the connection, which may fail with a <a class="el" href="a00017.html" title="Exception class for lost or failed backend connection. ">broken_connection</a> exception. </dd></dl>

</div>
</div>
<a class="anchor" id="aedf7ac72658efa92e702a06b1964747a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::inhibit_reactivation </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inhibit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disallow (or permit) connection recovery. </p>
<p>A connection whose underlying socket is not currently connected to the server will normally (re-)establish communication with the server whenever needed, or when the client program requests it (although for reasons of integrity, never inside a transaction; but retrying the whole transaction may implicitly cause the connection to be restored). In normal use this is quite a convenient thing to have and presents a simple, safe, predictable interface.</p>
<p>There is at least one situation where this feature is not desirable, however. Although most session state (prepared statements, session variables) is automatically restored to its working state upon connection reactivation, temporary tables and so-called WITH HOLD cursors (which can live outside transactions) are not.</p>
<p>Cursors that live outside transactions are automatically handled, and the library will quietly ignore requests to deactivate or reactivate connections while they exist; it does not want to give you the illusion of being back in your transaction when in reality you just dropped a cursor. With temporary tables this is not so easy: there is no easy way for the library to detect their creation or track their lifetimes.</p>
<p>So if your program uses temporary tables, and any part of this use happens outside of any database transaction (or spans multiple transactions), some of the work you have done on these tables may unexpectedly be undone if the connection is broken or deactivated while any of these tables exists, and then reactivated or implicitly restored before you are finished with it.</p>
<p>If this describes any part of your program, guard it against unexpected reconnections by inhibiting reconnection at the beginning. And if you want to continue doing work on the connection afterwards that no longer requires the temp tables, you can permit it again to get the benefits of connection reactivation for the remainder of the program.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inhibit</td><td>should reactivation be inhibited from here on?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Some connection types (the lazy and asynchronous types) defer completion of the socket-level connection until it is actually needed by the client program. Inhibiting reactivation before this connection is really established will prevent these connection types from doing their work. For those connection types, if you are sure that reactivation needs to be inhibited before any query goes across the connection, <a class="el" href="a00023.html#a1aa330287775aa1ff83f94714f772673" title="Explicitly activate deferred or deactivated connection. ">activate()</a> the connection first. This will ensure that definite activation happens before you inhibit it. </dd></dl>

</div>
</div>
<a class="anchor" id="a1d1c129c2c5797a82f251ee9dabec77e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="a00009.html#aa02e7329e13fdc9809c1215f224ab5fe">pqxx::basic_connection&lt; CONNECTPOLICY &gt;::basic_connection()</a>.</p>

</div>
</div>
<a class="anchor" id="a8fb51933d30f199f0a4efe4a35eff839"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pqxx::connection_base::is_open </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is this connection open at the moment? </p>
<dl class="section warning"><dt>Warning</dt><dd>This function is <b>not</b> needed in most code. Resist the temptation to check it after opening a connection; instead, rely on the <a class="el" href="a00017.html" title="Exception class for lost or failed backend connection. ">broken_connection</a> exception that will be thrown on connection failure. </dd></dl>

</div>
</div>
<a class="anchor" id="abf3b71372850f86e4f5e67eb4b7d56bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRANSACTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::perform </td>
          <td>(</td>
          <td class="paramtype">const TRANSACTOR &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Attempts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the transaction defined by a transactor-based object. </p>
<p>Invokes the given transactor, making at most Attempts attempts to perform the encapsulated code. If the code throws any exception other than <a class="el" href="a00017.html" title="Exception class for lost or failed backend connection. ">broken_connection</a>, it will be aborted right away.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The transactor to be executed. </td></tr>
    <tr><td class="paramname">Attempts</td><td>Maximum number of attempts to be made to execute T. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5eac9840b79e7f1893d88b63f6d97b1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TRANSACTOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::perform </td>
          <td>(</td>
          <td class="paramtype">const TRANSACTOR &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform the transaction defined by a transactor-based object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The transactor to be executed. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="a00023.html#a5eac9840b79e7f1893d88b63f6d97b1d">perform()</a>.</p>

<p>Referenced by <a class="el" href="a00023.html#a5eac9840b79e7f1893d88b63f6d97b1d">perform()</a>.</p>

</div>
</div>
<a class="anchor" id="a826750f0f13ede4ac4e6ca8a84711b53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * pqxx::connection_base::port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Server port number we're connected to. </p>
<dl class="section warning"><dt>Warning</dt><dd>This activates the connection, which may fail with a <a class="el" href="a00017.html" title="Exception class for lost or failed backend connection. ">broken_connection</a> exception. </dd></dl>

</div>
</div>
<a class="anchor" id="ab71d463277c017f695eed71cdd87afb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::prepare </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>definition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a prepared statement. </p>
<p>The statement's definition can refer to a parameter using the parameter's positional number n in the definition. For example, the first parameter can be used as a variable "$1", the second as "$2" and so on.</p>
<p>Here's an example of how to use prepared statements. Note the unusual syntax for passing parameters: every new argument is a parenthesized expression that is simply tacked onto the end of the statement!</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>pqxx;</div>
<div class="line"><span class="keywordtype">void</span> foo(<a class="code" href="a00023.html">connection_base</a> &amp;C)</div>
<div class="line">{</div>
<div class="line">  C.<a class="code" href="a00023.html#ab71d463277c017f695eed71cdd87afb2">prepare</a>(<span class="stringliteral">&quot;findtable&quot;</span>, <span class="stringliteral">&quot;select * from pg_tables where name=$1&quot;</span>);</div>
<div class="line">  <a class="code" href="a00101.html">work</a> W(C);</div>
<div class="line">  <a class="code" href="a00079.html">result</a> R = W.prepared(<span class="stringliteral">&quot;findtable&quot;</span>)(<span class="stringliteral">&quot;mytable&quot;</span>).exec();</div>
<div class="line">  <span class="keywordflow">if</span> (R.<a class="code" href="a00079.html#ad8270b53a71b01c17b77848756fb2b48">empty</a>()) <span class="keywordflow">throw</span> runtime_error(<span class="stringliteral">&quot;mytable not found!&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>To save time, prepared statements aren't really registered with the backend until they are first used. If this is not what you want, e.g. because you have very specific realtime requirements, you can use the <code><a class="el" href="a00023.html#a32efdc645566975851bfc7d6b82d214c" title="Request that prepared statement be registered with the server. ">prepare_now()</a></code> function to force immediate preparation.</p>
<dl class="section warning"><dt>Warning</dt><dd>The statement may not be registered with the backend until it is actually used. So if, for example, the statement is syntactically incorrect, you may see a <a class="el" href="a00095.html">syntax_error</a> here, or later when you try to call the statement, or in a <a class="el" href="a00023.html#a32efdc645566975851bfc7d6b82d214c" title="Request that prepared statement be registered with the server. ">prepare_now()</a> call.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>unique name for the new prepared statement. </td></tr>
    <tr><td class="paramname">definition</td><td>SQL statement to prepare. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d3fc0b15713b0bba8a6a286e4e67c10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::prepare </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>definition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a nameless prepared statement. </p>
<p>This can be useful if you merely want to pass large binary parameters to a statement without otherwise wishing to prepare it. If you use this feature, always keep the definition and the use close together to avoid the nameless statement being redefined unexpectedly by code somewhere else. </p>

</div>
</div>
<a class="anchor" id="a32efdc645566975851bfc7d6b82d214c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::prepare_now </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request that prepared statement be registered with the server. </p>
<p>If the statement had already been fully prepared, this will do nothing.</p>
<p>If the connection should break and be transparently restored, then the new connection will again defer registering the statement with the server. Since connections are never restored inside backend transactions, doing this once at the beginning of your transaction ensures that the statement will not be re-registered during that transaction. In most cases, however, it's probably better not to use this and let the connection decide when and whether to register prepared statements that you've defined. </p>

</div>
</div>
<a class="anchor" id="a202f719a96eeb2e9269008d475ebb3d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::process_notice </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>msg</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke notice processor function. The message should end in newline. </p>

</div>
</div>
<a class="anchor" id="a80a38dd435013aa2dd77009bc6a5676f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::process_notice </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke notice processor function. Newline at end is recommended. </p>

</div>
</div>
<a class="anchor" id="a08d8108b0d5c95e7e3b8bb79c71ee363"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pqxx::connection_base::protocol_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>What version of the PostgreSQL protocol is this connection using? </p>
<p>The answer can be 0 (when there is no connection); 3 for protocol 3.0; or possibly higher values as newer protocol versions are taken into use.</p>
<p>If the connection is broken and restored, the restored connection could possibly use a different server and protocol version. This would normally happen if the server is upgraded without shutting down the client program, for example. </p>

</div>
</div>
<a class="anchor" id="a575d985e6f1462ae506e7e7047929680"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pqxx::connection_base::server_version </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>What version of the PostgreSQL server are we connected to? </p>
<p>The result is a bit complicated: each of the major, medium, and minor release numbers is written as a two-digit decimal number, and the three are then concatenated. Thus server version 9.4.2 will be returned as the decimal number 90402. If there is no connection to the server, this returns zero.</p>
<dl class="section warning"><dt>Warning</dt><dd>When writing version numbers in your code, don't add zero at the beginning! Numbers beginning with zero are interpreted as octal (base-8) in C++. Thus, 070402 is not the same as 70402, and 080000 is not a number at all because there is no digit "8" in octal notation. Use strictly decimal notation when it comes to these version numbers. </dd></dl>

</div>
</div>
<a class="anchor" id="a04895c06c5ae1d8b0863a32a28beff51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::set_client_encoding </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>Encoding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set client-side character encoding. </p>
<p>Search the PostgreSQL documentation for "multibyte" or "character set
encodings" to find out more about the available encodings, how to extend them, and how to use them. Not all server-side encodings are compatible with all client-side encodings or vice versa. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Encoding</td><td>Name of the character set encoding to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a120b9e03dcaa9b0c3ef7026afa64d954"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::set_variable </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>Var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set session variable. </p>
<p>Set a session variable for this connection, using the SET command. If the connection to the database is lost and recovered, the last-set value will be restored automatically. See the PostgreSQL documentation for a list of variables that can be set and their permissible values. If a transaction is currently in progress, aborting that transaction will normally discard the newly set value. However nontransaction (which doesn't start a real backend transaction) is an exception.</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not mix the set_variable interface with manual setting of variables by executing the corresponding SQL commands, and do not get or set variables while a tablestream or pipeline is active on the same connection. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Var</td><td>Variable to set </td></tr>
    <tr><td class="paramname">Value</td><td>Value vor Var to assume: an identifier, a quoted string, or a number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8693430afb7aeefc136658c7ef10cb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::set_verbosity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00023.html#a985f29750a981c8ba80bf91b22c2eee9">error_verbosity</a>&#160;</td>
          <td class="paramname"><em>verbosity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set session verbosity. </p>
<p>Set the verbosity of error messages to "terse", "normal" (i.e. default) or "verbose."</p>
<p>If "terse", returned messages include severity, primary text, and position only; this will normally fit on a single line. "normal" produces messages that include the above plus any detail, hint, or context fields (these might span multiple lines). "verbose" includes all available fields. </p>

</div>
</div>
<a class="anchor" id="a335ca1d83e65a9e57b907c431c3afbe1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::simulate_failure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make the connection fail. </p>
<dl class="section warning"><dt>Warning</dt><dd>Do not use this except for testing! Breaks the connection in some unspecified, horrible, dirty way to enable failure testing.</dd></dl>
<p>Do not use this in normal programs. This is only meant for testing. </p>

</div>
</div>
<a class="anchor" id="ae83b8717abba48d933df17df06643ee4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pqxx::connection_base::sock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Socket currently used for connection, or -1 for none. Use with care! </p>
<p>Query the current socket number. This is intended for event loops based on functions such as select() or poll(), where multiple file descriptors are watched.</p>
<p>Please try to stay away from this function. It is really only meant for event loops that need to wait on more than one file descriptor. If all you need is to block until a notification arrives, for instance, use <a class="el" href="a00023.html#ab5c24029bda3198d826d24757e49c746" title="Wait for a notification to come in. ">await_notification()</a>. If you want to issue queries and retrieve results in nonblocking fashion, check out the pipeline class.</p>
<dl class="section warning"><dt>Warning</dt><dd>Don't store this value anywhere, and always be prepared for the possibility that there is no socket. The socket may change or even go away during any invocation of libpqxx code, no matter how trivial. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ff3f9172fa6b1c6b96359502536ad1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pqxx::connection_base::supports </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00023.html#a306a884246abc1051bab4fb06393ee71">capability</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does this connection seem to support the given capability? </p>
<p>Don't try to be smart by caching this information anywhere. Obtaining it is quite fast (especially after the first time) and what's more, a capability may "suddenly" appear or disappear if the connection is broken or deactivated, and then restored. This may happen silently any time no backend transaction is active; if it turns out that the server was upgraded or restored from an older backup, or the new connection goes to a different backend, then the restored session may have different capabilities than were available previously.</p>
<p>Some guesswork is involved in establishing the presence of any capability; try not to rely on this function being exactly right.</p>
<dl class="section warning"><dt>Warning</dt><dd>Make sure your connection is active before calling this function, or the answer will always be "no." In particular, if you are using this function on a newly-created lazyconnection, activate the connection first. </dd></dl>

</div>
</div>
<a class="anchor" id="a29a128da8bcea7991500b509e58b17ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::trace </td>
          <td>(</td>
          <td class="paramtype">std::FILE *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable tracing to a given output stream, or NULL to disable. </p>

</div>
</div>
<a class="anchor" id="a30ec51634479614b45106532e87e5dc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::unprepare </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop prepared statement. </p>

</div>
</div>
<a class="anchor" id="ae02522000400fc2782e892ac0387d85b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * pqxx::connection_base::username </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Database user ID we're connected under, if any. </p>
<dl class="section warning"><dt>Warning</dt><dd>This activates the connection, which may fail with a <a class="el" href="a00017.html" title="Exception class for lost or failed backend connection. ">broken_connection</a> exception. </dd></dl>

</div>
</div>
<a class="anchor" id="af860fe4c418cfa4f573f34d73327d111"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::wait_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="a00187.html#aab24f7cf8fda5527887819f620eea4be">pqxx::internal::wait_read()</a>.</p>

</div>
</div>
<a class="anchor" id="ab8c7dd5e54493e18d5900dd70012d062"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::wait_read </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>seconds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>microseconds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="a00187.html#aab24f7cf8fda5527887819f620eea4be">pqxx::internal::wait_read()</a>.</p>

</div>
</div>
<a class="anchor" id="acfb8d53e6f105db280cd5d977c005bea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pqxx::connection_base::wait_write </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References <a class="el" href="a00187.html#a578ac9f03e48ac2c6489456b6843ecb7">pqxx::internal::wait_write()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="af3dfec559fe2305e57aba653abe4c8ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::gate::connection_dbtransaction</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa423170b8ec82df685a1e739f53f2b14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::gate::connection_errorhandler</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab15ff67d81467d271dc713b2584f1328"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::gate::connection_largeobject</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abbdbf8e505eb3c23680d83df6c575889"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::gate::connection_notification_receiver</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0e64dc314f291c6f81a948c59d94aa8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::gate::connection_parameterized_invocation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3b9c5dc16f04600aa5415e06f6ff8fa6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::gate::connection_pipeline</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac2eff365ba0aa25ebbf5f903ac3c7a54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::gate::connection_prepare_invocation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2247d8690958f634898bbf014a7d418c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::gate::connection_reactivation_avoidance_exemption</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a84c1a28176815ab9103c7febec450755"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::gate::connection_sql_cursor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3c60c76e32687adce1e8c0dba0919773"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::gate::connection_transaction</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="a00125_source.html">connection_base.hxx</a></li>
<li><a class="el" href="a00170_source.html">transactor.hxx</a></li>
<li>connection_base.cxx</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00186.html">pqxx</a></li><li class="navelem"><a class="el" href="a00023.html">connection_base</a></li>
    <li class="footer">Generated on Fri May 22 2015 01:14:25 for libpqxx by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
